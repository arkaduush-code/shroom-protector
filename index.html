<!DOCTYPE html>
<html>
<head>
    <title>The Shroom Protector</title>
    <meta name="x-ogp-key" content="657c89e6-1d39-472f-aa21-b6ef8dc732ff" id="ogp-key-meta" />
    
    <style>
        body { margin: 0; background-color: #020202; color: #00ffcc; font-family: 'Courier New', Courier, monospace; text-align: center; overflow: hidden; }
        .header-container { display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 10px; margin-bottom: 5px; }
        .header-logo { font-size: 35px; text-shadow: 0px 0px 20px #00ffcc; filter: drop-shadow(0px 0px 10px rgba(0, 255, 204, 0.8)); }
        h2 { margin: 0; color: #00ffcc; letter-spacing: 4px; text-shadow: 0px 0px 15px #00ffcc; font-size: 30px;}
        #gameHUD { display: flex; justify-content: space-between; align-items: center; width: 1200px; margin: 5px auto; font-size: 18px; font-weight: bold; color: #00ffcc; text-shadow: 0px 0px 10px #00ffcc; }
        
        .hp-container { width: 300px; height: 25px; border: 2px solid #fff; border-radius: 5px; background: #330000; position: relative; overflow: hidden;}
        #hpFill { height: 100%; width: 100%; background: #00ff00; transition: width 0.2s, background-color 0.2s; box-shadow: 0px 0px 10px #00ff00; }
        .hp-text { position: absolute; top: 2px; left: 0; width: 100%; text-align: center; color: white; font-size: 16px; text-shadow: 1px 1px 2px black; z-index: 2; }

        .game-wrapper { position: relative; width: 1200px; height: 750px; margin: 0 auto; border: 3px solid #00ffcc; border-radius: 10px; box-shadow: 0px 0px 60px rgba(0, 255, 204, 0.4); overflow: hidden; background-color: #050508; }
        canvas { display: block; }
        .scanlines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 4px, 3px 100%; pointer-events: none; z-index: 10; }
        
        .command-guide { width: 1200px; margin: 10px auto; padding: 10px; border: 1px solid #00ffcc; background: rgba(0, 255, 204, 0.1); border-radius: 5px; color: #fff; font-size: 16px; display: flex; justify-content: space-around; text-shadow: 0px 0px 5px #00ffcc;}
        .highlight { color: #ff00ff; font-weight: bold; text-shadow: 0px 0px 8px #ff00ff;}

        #gameOverScreen { display: none; position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 50px; border: 2px solid #ff0000; border-radius: 10px; box-shadow: 0px 0px 50px #ff0000; z-index: 20; }
        #modeDisplay { background-color: #00ffcc; color: black; padding: 5px 15px; font-size: 16px; border-radius: 5px; font-weight: bold; box-shadow: 0px 0px 15px #00ffcc; min-width: 250px; }
        #modeDisplay.manual { background-color: #ff00ff; box-shadow: 0px 0px 15px #ff00ff; color: white; }
        .reboot-btn { background-color: #ff0000; color: white; border: none; padding: 15px 30px; font-size: 20px; cursor: pointer; border-radius: 5px; font-weight: bold; margin-top: 15px; }
        .reboot-btn:hover { background-color: #cc0000; }
    </style>
</head>
<body>

    <div class="header-container">
        <div class="header-logo">üëΩüçÑ</div>
        <h2>THE SHROOM PROTECTOR</h2>
        <div class="header-logo">üçÑüëΩ</div>
    </div>

    <div id="gameHUD">
        <div id="scoreDisplay">Score: 0</div>
        
        <div class="hp-container">
            <div id="hpFill"></div>
            <div class="hp-text" id="hpText">HULL INTEGRITY: 100%</div>
        </div>

        <div id="modeDisplay">ü§ñ AUTO</div>
        <div id="bombDisplay">üí• Bombs: 1</div>
        <div id="levelDisplay">Level: 1</div>
    </div>

    <div class="game-wrapper">
        <div class="scanlines"></div>
        <canvas id="gameCanvas" width="1200" height="750"></canvas>
    </div>

    <div class="command-guide">
        <span><span class="highlight">MODE TOGGLE:</span> Press 'M' for Manual / 'A' for Auto</span>
        <span><span class="highlight">MANUAL MOVEMENT:</span> Left & Right Arrows</span>
        <span><span class="highlight">MANUAL ATTACK:</span> Hold Spacebar</span>
        <span><span class="highlight">SMART BOMB:</span> Press 'B' (Manual Only)</span>
    </div>

    <div id="gameOverScreen">
        <h1 id="endTitle" style="color: red; font-size: 45px; margin-top: 0; text-shadow: 0px 0px 20px red;">HULL DESTROYED</h1>
        <p style="color: white; font-size: 24px;">Final Score: <span id="finalScore">0</span></p>
        <button class="reboot-btn" onclick="restartGame()">REBOOT PROTECTOR</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const bombDisplay = document.getElementById('bombDisplay');
        const modeDisplay = document.getElementById('modeDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScore = document.getElementById('finalScore');
        const endTitle = document.getElementById('endTitle');
        const hpFill = document.getElementById('hpFill');
        const hpText = document.getElementById('hpText');

        let animationId, score = 0, level = 1, bombs = 1, isGameOver = false, isSpawning = false, isAutoMode = true;
        let lastShotTime = 0, lastHeadRocketTime = 0;
        let bossAlertText = "", bossAlertTimer = 0;

        const player = { 
            x: canvas.width / 2, y: canvas.height - 90, speed: 15,
            hp: 100, maxHp: 100, invulnTimer: 0 
        };

        const keys = { ArrowLeft: false, ArrowRight: false, Space: false };
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
            if (e.code === 'ArrowRight') keys.ArrowRight = true;
            if (e.code === 'Space') { keys.Space = true; e.preventDefault(); }
            if ((e.code === 'KeyB' || e.key === 'b') && !isAutoMode) useBomb();
            if (e.code === 'KeyM' || e.key === 'm') setManualMode();
            if (e.code === 'KeyA' || e.key === 'a') setAutoMode();
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
            if (e.code === 'ArrowRight') keys.ArrowRight = false;
            if (e.code === 'Space') keys.Space = false;
        });

        function setManualMode() {
            if (isAutoMode) { isAutoMode = false; modeDisplay.innerText = "üïπÔ∏è MANUAL"; modeDisplay.classList.add('manual'); }
        }
        function setAutoMode() {
            if (!isAutoMode) { isAutoMode = true; modeDisplay.innerText = "ü§ñ AUTO"; modeDisplay.classList.remove('manual'); }
        }

        function updateHP() {
            let pct = Math.max(0, (player.hp / player.maxHp) * 100);
            hpFill.style.width = pct + "%";
            hpText.innerText = `HULL INTEGRITY: ${Math.ceil(pct)}%`;
            if (pct > 60) hpFill.style.background = "#00ff00";
            else if (pct > 30) hpFill.style.background = "#ffff00";
            else hpFill.style.background = "#ff0000";

            if (player.hp <= 0 && !isGameOver) endGame();
        }

        const levelColors = ['#00FF00', '#00FA33', '#00F566', '#00F099', '#00EBCC', '#00D6FF', '#00A3FF', '#0070FF', '#3333FF', '#6600FF', '#9900FF', '#CC00FF', '#FF00FF', '#FF00CC', '#FF0099', '#FF0066', '#FF0033', '#FF0000', '#CC0000', '#8B0000'];

        let projectiles = [], enemies = [], bossProjectiles = [], particles = [], activeBoss = null, screenShake = 0;
        let stars = [];
        for (let i = 0; i < 200; i++) stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 2 + 0.5, speed: Math.random() * 3 + 0.5, alpha: Math.random() });

        function createExplosion(x, y, color, amount) {
            for(let i=0; i<amount; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0, color: color,
                    size: Math.random() * 5 + 2
                });
            }
        }

        function useBomb() {
            if (bombs > 0 && !isGameOver) {
                bombs--; bombDisplay.innerText = `üí• Bombs: ${bombs}`;
                let visibleEnemies = enemies.filter(e => e.y > 0);
                score += visibleEnemies.length * 10; enemies = []; bossProjectiles = [];
                if (activeBoss && activeBoss.y > 0) {
                    activeBoss.hp -= 1500;
                    createExplosion(activeBoss.x, activeBoss.y, "orange", 50);
                }
                ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height);
                scoreDisplay.innerText = "Score: " + score; checkLevelComplete();
            }
        }

        function shoot() {
            let beamWidth = 8 + (level * 2), beamLength = 50 + (level * 15); 
            let beamColor = levelColors[Math.min(level - 1, 19)];
            let damage = 25 + (level * 10); 

            projectiles.push({ type: 'laser', x: player.x, y: player.y - 40, width: beamWidth, height: beamLength, color: beamColor, velocityX: 0, velocityY: -25, damage: damage });
            if (level >= 5) {
                projectiles.push({ type: 'laser', x: player.x - 30, y: player.y - 20, width: beamWidth/2, height: beamLength/1.5, color: beamColor, velocityX: 0, velocityY: -22, damage: damage/2 });
                projectiles.push({ type: 'laser', x: player.x + 30, y: player.y - 20, width: beamWidth/2, height: beamLength/1.5, color: beamColor, velocityX: 0, velocityY: -22, damage: damage/2 });
            }
            if (level >= 4) {
                let rocketDmg = 100 + (level * 20);
                projectiles.push({ type: 'rocket', x: player.x - 50, y: player.y, width: 10, height: 30, color: '#FF4500', velocityX: -4, velocityY: -12, damage: rocketDmg });
                projectiles.push({ type: 'rocket', x: player.x + 50, y: player.y, width: 10, height: 30, color: '#FF4500', velocityX: 4, velocityY: -12, damage: rocketDmg });
            }
            if (level >= 8) screenShake = 5;
        }

        function fireHeadRocket() {
            if (level >= 5 && !isGameOver) {
                let target = (activeBoss && activeBoss.y > 0) ? activeBoss : (enemies.length > 0 ? enemies[0] : null);
                if (target) {
                    let heavyDmg = 400 + (level * 50); 
                    projectiles.push({ type: 'heavy_rocket', x: player.x, y: player.y - 80, width: 18, height: 45, color: '#FFFFFF', velocityX: 0, velocityY: -15, damage: heavyDmg });
                    screenShake = 10; 
                }
            }
        }

        const bossData = {
            3: { name: "THE SLUDGE MOUTH", hp: 2000, color: "#4a5d23", shape: "blob", atkRate: 2000, speed: 0.3 },
            6: { name: "CRIMSON WATCHER", hp: 4500, color: "#8B0000", shape: "diamond", atkRate: 1500, speed: 0.4 },
            9: { name: "TOXIC SWARM LORD", hp: 8000, color: "#660099", shape: "insect", atkRate: 1200, speed: 0.5 },
            12: { name: "MECHA-SPORE", hp: 12000, color: "#557788", shape: "robot", atkRate: 900, speed: 0.55 },
            15: { name: "VOID GOLIATH", hp: 17000, color: "#111111", shape: "crystal", atkRate: 700, speed: 0.6 },
            18: { name: "ELDER ABOMINATION", hp: 25000, color: "#994400", shape: "tentacles", atkRate: 500, speed: 0.7 },
            20: { name: "MOTHERSHIP OMEGA", hp: 50000, color: "#cccccc", shape: "ufo", atkRate: 300, speed: 0.3 }
        };

        function spawnWave() {
            isSpawning = true;
            
            if ((level % 3 === 0 && level < 20) || level === 20) {
                let bData = bossData[level];
                activeBoss = {
                    name: bData.name, levelType: level, x: canvas.width / 2, y: -250, 
                    hp: bData.hp, maxHp: bData.hp, shape: bData.shape, color: bData.color,
                    width: 180 + (level * 10), height: 140 + (level * 10),
                    speedY: bData.speed, time: 0, lastAtk: Date.now()
                };
                bossAlertText = activeBoss.name;
                bossAlertTimer = 150; 
            } else {
                let enemyCount = 6 + (level * 4); 
                let speed = 1.5 + (level * 0.2); 
                for (let i = 0; i < enemyCount; i++) {
                    enemies.push({ x: Math.random() * (canvas.width - 60) + 30, y: Math.random() * -1200 - 50, radius: 22, speed: speed });
                }
            }
            isSpawning = false;
        }

        function drawBoss() {
            if (!activeBoss) return;
            activeBoss.time += 0.05;
            
            let sway = activeBoss.levelType === 20 ? 450 : 350;
            activeBoss.x = (canvas.width / 2) + Math.sin(activeBoss.time) * sway;
            if (activeBoss.y < 150) activeBoss.y += activeBoss.speedY; 

            let bx = activeBoss.x, by = activeBoss.y, bw = activeBoss.width, bh = activeBoss.height;

            ctx.fillStyle = activeBoss.color;
            ctx.lineWidth = 4; ctx.strokeStyle = "#fff";
            
            ctx.beginPath();
            if (activeBoss.shape === "blob") {
                ctx.ellipse(bx, by, bw/2, bh/2, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.fillStyle="black"; ctx.ellipse(bx, by+20, bw/3, bh/4, 0, 0, Math.PI*2); ctx.fill(); 
            } 
            else if (activeBoss.shape === "diamond") {
                ctx.moveTo(bx, by - bh/2); ctx.lineTo(bx + bw/2, by); ctx.lineTo(bx, by + bh/2); ctx.lineTo(bx - bw/2, by); ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.fillStyle="red"; ctx.beginPath(); ctx.arc(bx, by, 30, 0, Math.PI*2); ctx.fill(); 
            }
            else if (activeBoss.shape === "insect") {
                ctx.arc(bx, by - bh/3, bw/3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.arc(bx - bw/4, by + bh/4, bw/4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.arc(bx + bw/4, by + bh/4, bw/4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.fillStyle="lime"; ctx.beginPath(); ctx.arc(bx-bw/4, by+bh/4, 15,0,Math.PI*2); ctx.arc(bx+bw/4, by+bh/4, 15,0,Math.PI*2); ctx.fill();
            }
            else if (activeBoss.shape === "robot") {
                ctx.fillRect(bx - bw/2, by - bh/2, bw, bh); ctx.strokeRect(bx - bw/2, by - bh/2, bw, bh);
                ctx.fillStyle="#00ffff"; ctx.fillRect(bx-bw/3, by-bh/4, bw/1.5, bh/4); 
            }
            else if (activeBoss.shape === "crystal") {
                for(let i=0; i<8; i++){
                    let ang = (i * Math.PI) / 4; let out = (i%2===0)? bw/2 : bw/4;
                    ctx.lineTo(bx + Math.cos(ang)*out, by + Math.sin(ang)*out);
                }
                ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.fillStyle="#ff00ff"; ctx.beginPath(); ctx.arc(bx, by, 25, 0, Math.PI*2); ctx.fill();
            }
            else if (activeBoss.shape === "tentacles") {
                ctx.ellipse(bx, by, bw/2.5, bh/2.5, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.strokeStyle = activeBoss.color; ctx.lineWidth = 15;
                for(let i=-2; i<=2; i++){
                    ctx.beginPath(); ctx.moveTo(bx + (i*30), by+20);
                    ctx.quadraticCurveTo(bx + (i*50) + Math.sin(activeBoss.time*2)*50, by + bh, bx + (i*40), by + bh + 100); ctx.stroke();
                }
            }
            else if (activeBoss.shape === "ufo") {
                ctx.ellipse(bx, by, bw/1.5, bh/3, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = "rgba(0, 255, 255, 0.4)"; ctx.beginPath(); ctx.arc(bx, by - bh/4, bw/4, Math.PI, 0); ctx.fill(); ctx.stroke();
            }

            if (activeBoss.y > 0) {
                let hpPercent = Math.max(0, activeBoss.hp / activeBoss.maxHp);
                ctx.fillStyle = "red"; ctx.fillRect(bx - bw/2, by - bh/2 - 40, bw, 20);
                ctx.fillStyle = "#00ff00"; ctx.fillRect(bx - bw/2, by - bh/2 - 40, bw * hpPercent, 20);
                ctx.strokeStyle = "white"; ctx.strokeRect(bx - bw/2, by - bh/2 - 40, bw, 20);

                if (Date.now() - activeBoss.lastAtk > bossData[level].atkRate) {
                    let bDmg = 15 + (level * 2);
                    bossProjectiles.push({ x: bx, y: by + bh/2, vx: 0, vy: 10 + (level*0.5), size: 15, dmg: bDmg });
                    if (level >= 9) {
                        bossProjectiles.push({ x: bx, y: by + bh/2, vx: -4, vy: 9 + (level*0.5), size: 15, dmg: bDmg });
                        bossProjectiles.push({ x: bx, y: by + bh/2, vx: 4, vy: 9 + (level*0.5), size: 15, dmg: bDmg });
                    }
                    if (level === 20) {
                        bossProjectiles.push({ x: bx, y: by + bh/2, vx: -8, vy: 8, size: 20, dmg: bDmg });
                        bossProjectiles.push({ x: bx, y: by + bh/2, vx: 8, vy: 8, size: 20, dmg: bDmg });
                    }
                    activeBoss.lastAtk = Date.now();
                }
            }
        }

        function drawPlayer() {
            let size = 25 + (Math.min(level, 20) * 2.5); 
            let shakeX = (Math.random() - 0.5) * screenShake, shakeY = (Math.random() - 0.5) * screenShake;
            let pX = player.x + shakeX, pY = player.y + shakeY;
            let baseColor = levelColors[Math.min(level - 1, 19)];

            if (player.invulnTimer > 0) {
                player.invulnTimer--;
                if (player.invulnTimer % 10 < 5) return; 
            }

            if (level >= 5) {
                ctx.fillStyle = "#555"; ctx.strokeStyle = "#ccc"; ctx.lineWidth = 2;
                ctx.fillRect(pX - 12, pY - size - 25, 24, 30); 
                ctx.strokeRect(pX - 12, pY - size - 25, 24, 30);
                ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(pX, pY - size - 25, 8, Math.PI, 0); ctx.fill();
            }

            ctx.fillStyle = '#cccccc'; ctx.strokeStyle = '#555555'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(pX - size/3, pY + size * 1.5); ctx.quadraticCurveTo(pX - size/4, pY, pX - size/6, pY - size/2); 
            ctx.lineTo(pX + size/6, pY - size/2); ctx.quadraticCurveTo(pX + size/4, pY, pX + size/3, pY + size * 1.5); ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.fillStyle = baseColor; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(pX - size * 1.4, pY + size/4); ctx.bezierCurveTo(pX - size * 1.4, pY - size * 1.5, pX + size * 1.4, pY - size * 1.5, pX + size * 1.4, pY + size/4); 
            ctx.bezierCurveTo(pX + size, pY + size/2, pX - size, pY + size/2, pX - size * 1.4, pY + size/4); ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.beginPath(); ctx.ellipse(pX - size/2, pY - size/1.5, size/5, size/8, Math.PI/4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(pX + size/2, pY - size/2, size/4, size/6, -Math.PI/6, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(pX, pY - size, size/3, size/5, 0, 0, Math.PI*2); ctx.fill();

            let eyeTilt = level * 1.2; 
            ctx.fillStyle = "white";
            ctx.beginPath(); ctx.moveTo(pX - size/2, pY - size/5); ctx.lineTo(pX - size/6, pY + eyeTilt - size/6); ctx.lineTo(pX - size/2, pY + eyeTilt + 5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(pX + size/2, pY - size/5); ctx.lineTo(pX + size/6, pY + eyeTilt - size/6); ctx.lineTo(pX + size/2, pY + eyeTilt + 5); ctx.fill();

            ctx.fillStyle = "red";
            ctx.beginPath(); ctx.arc(pX - size/4, pY + eyeTilt - size/10, 3 + (level*0.2), 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(pX + size/4, pY + eyeTilt - size/10, 3 + (level*0.2), 0, Math.PI*2); ctx.fill();
            
            ctx.lineWidth = 3 + (level * 0.4); ctx.strokeStyle = "black";
            ctx.beginPath(); ctx.moveTo(pX - (size/1.2), pY - (size/3)); ctx.lineTo(pX - 2, pY + eyeTilt - (size/6)); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(pX + (size/1.2), pY - (size/3)); ctx.lineTo(pX + 2, pY + eyeTilt - (size/6)); ctx.stroke();

            ctx.fillStyle = "black"; ctx.beginPath();
            let mTop = pY + size/1.5, mBot = pY + size - 5 + (level*1.5); 
            ctx.moveTo(pX - size/2, mTop); ctx.lineTo(pX - size/4, mBot); ctx.lineTo(pX, mTop + 5);
            ctx.lineTo(pX + size/4, mBot); ctx.lineTo(pX + size/2, mTop); ctx.fill();
            
            if (screenShake > 0) screenShake -= 1;
        }

        function takeDamage(amt) {
            if (player.invulnTimer <= 0) {
                player.hp -= amt;
                player.invulnTimer = 60; 
                screenShake = 20;
                ctx.fillStyle = "rgba(255,0,0,0.5)";
                ctx.fillRect(0,0,canvas.width,canvas.height);
                createExplosion(player.x, player.y, "#00ff00", 30);
                updateHP();
            }
        }

        function checkLevelComplete() {
            if ((enemies.length === 0 && !activeBoss) && !isSpawning) {
                isSpawning = true; 
                
                if (level % 2 === 0) bombs++;
                bombDisplay.innerText = `üí• Bombs: ${bombs}`;

                player.hp = Math.min(player.maxHp, player.hp + 20);
                updateHP();

                if (level === 20) {
                    endTitle.innerText = "EARTH SECURED!";
                    endTitle.style.color = "#00ffcc"; endTitle.style.textShadow = "0px 0px 20px #00ffcc";
                    endGame(); return;
                }

                level++;
                levelDisplay.innerText = `Level: ${level}`;
                setTimeout(spawnWave, 2000); 
            }
            
            if (activeBoss && activeBoss.hp <= 0) {
                createExplosion(activeBoss.x, activeBoss.y, activeBoss.color, 200);
                if (activeBoss.levelType === 20) score += 50000;
                else score += 2000 * level;
                
                scoreDisplay.innerText = "Score: " + score;
                activeBoss = null;
                bossProjectiles = []; 
                checkLevelComplete(); 
            }
        }

        function animate() {
            if (isGameOver) return;
            animationId = requestAnimationFrame(animate);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            stars.forEach(star => {
                star.y += star.speed; 
                if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; }
                ctx.fillStyle = `rgba(200, 255, 255, ${star.alpha})`;
                ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fill();
            });

            for(let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx; p.y += p.vy; p.life -= 0.03;
                if(p.life <= 0) { particles.splice(i, 1); continue; }
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0;
            }

            if (level >= 5 && Date.now() - lastHeadRocketTime > 5000) {
                fireHeadRocket(); lastHeadRocketTime = Date.now();
            }

            let currentSpeed = player.speed + (level * 0.4); 
            let currentFireRate = 120; 
            let pSize = 25 + (level * 2.5);

            if (isAutoMode) {
                let target = null;
                let visibleEnemies = enemies.filter(e => e.y > 0); 
                
                if (activeBoss && activeBoss.y > 0) target = activeBoss;
                else if (visibleEnemies.length > 0) {
                    target = visibleEnemies[0];
                    for(let i = 1; i < visibleEnemies.length; i++) {
                        if(visibleEnemies[i].y > target.y) target = visibleEnemies[i];
                    }
                }

                let dodging = false;
                for (let bp of bossProjectiles) {
                    if (bp.y > player.y - 250 && Math.abs(bp.x - player.x) < 50) {
                        dodging = true;
                        if (bp.x > player.x && player.x - pSize > 0) player.x -= currentSpeed;
                        else if (player.x + pSize < canvas.width) player.x += currentSpeed;
                        break; 
                    }
                }

                if (!dodging && target && currentSpeed > 0) {
                    if (player.x < target.x - 5 && player.x + pSize * 1.5 < canvas.width) player.x += currentSpeed;
                    else if (player.x > target.x + 5 && player.x - pSize * 1.5 > 0) player.x -= currentSpeed;

                    if (Math.abs(player.x - target.x) < 80 + (level*5)) {
                        if (Date.now() - lastShotTime > currentFireRate) { shoot(); lastShotTime = Date.now(); }
                    }
                }
            } else {
                if (keys.ArrowLeft && player.x - pSize * 1.5 > 0) player.x -= currentSpeed;
                if (keys.ArrowRight && player.x + pSize * 1.5 < canvas.width) player.x += currentSpeed;
                if (keys.Space && Date.now() - lastShotTime > currentFireRate) { shoot(); lastShotTime = Date.now(); }
            }
            
            drawBoss();
            drawPlayer();

            if (bossAlertTimer > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${Math.min(bossAlertTimer / 50, 1)})`;
                ctx.font = "bold 60px Courier New"; ctx.textAlign = "center";
                ctx.shadowBlur = 20; ctx.shadowColor = "red";
                ctx.fillText(`üö® WARNING: ${bossAlertText} üö®`, canvas.width/2, canvas.height/2);
                ctx.shadowBlur = 0; bossAlertTimer--;
            }

            for(let i = bossProjectiles.length - 1; i >= 0; i--) {
                let bp = bossProjectiles[i];
                bp.x += bp.vx; bp.y += bp.vy;
                
                ctx.shadowBlur = 10; ctx.shadowColor = "red"; ctx.fillStyle = "#ff3300";
                ctx.beginPath(); ctx.arc(bp.x, bp.y, bp.size, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;

                if (Math.hypot(player.x - bp.x, player.y - bp.y) < pSize + bp.size) {
                    takeDamage(bp.dmg);
                    bossProjectiles.splice(i, 1);
                    continue;
                }
                if (bp.y > canvas.height) bossProjectiles.splice(i, 1);
            }

            projectiles.forEach((p, index) => {
                if (p.type === 'rocket' || p.type === 'heavy_rocket') {
                    let visibleEnemies = enemies.filter(e => e.y > 0);
                    let target = (activeBoss && activeBoss.y > 0) ? activeBoss : (visibleEnemies.length > 0 ? visibleEnemies[0] : null);
                    if (target) {
                        let trackingSpeed = p.type === 'heavy_rocket' ? 1.5 : 0.8; 
                        if (target.x > p.x) p.velocityX += trackingSpeed;
                        if (target.x < p.x) p.velocityX -= trackingSpeed;
                    }
                    ctx.shadowBlur = 10; ctx.shadowColor = "orange"; ctx.fillStyle = "yellow";
                    ctx.fillRect(p.x - p.width/2 + 2, p.y + p.height, p.width - 4, p.type==='heavy_rocket' ? 25 : 15);
                }

                p.x += p.velocityX; p.y += p.velocityY;
                
                ctx.shadowBlur = 15; ctx.shadowColor = p.color; ctx.fillStyle = "white"; 
                ctx.fillRect(p.x - p.width/2, p.y, p.width, p.height);
                ctx.strokeStyle = p.color; ctx.lineWidth = 4; ctx.strokeRect(p.x - p.width/2, p.y, p.width, p.height);
                ctx.shadowBlur = 0; 

                if (p.y + p.height < 0) projectiles.splice(index, 1);

                if (activeBoss && activeBoss.y > 0 && p.x > activeBoss.x - activeBoss.width/2 && p.x < activeBoss.x + activeBoss.width/2 && p.y < activeBoss.y + activeBoss.height/2) {
                    activeBoss.hp -= p.damage;
                    createExplosion(p.x, p.y, p.color, 5); 
                    projectiles.splice(index, 1);
                    
                    if (p.type === 'heavy_rocket') {
                        createExplosion(p.x, p.y, "orange", 30);
                        ctx.fillStyle = "rgba(255, 165, 0, 0.5)"; ctx.beginPath(); ctx.arc(p.x, p.y, 60, 0, Math.PI*2); ctx.fill();
                    }
                    checkLevelComplete(); 
                }
            });

            enemies.forEach((enemy, eIndex) => {
                enemy.y += enemy.speed;
                ctx.font = "45px Arial"; ctx.textAlign = "center";
