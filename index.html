<!DOCTYPE html>
<html>
<head>
    <title>The Shroom Protector</title>
    
    <style>
        body {
            margin: 0;
            background-color: #020202; 
            color: #00ffcc; 
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            overflow-x: hidden; 
            padding-bottom: 30px;
        }
        .header-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .header-logo {
            font-size: 30px;
            text-shadow: 0px 0px 20px #00ffcc;
            filter: drop-shadow(0px 0px 10px rgba(0, 255, 204, 0.8));
        }
        h2 {
            margin: 0; 
            color: #00ffcc; 
            letter-spacing: 4px;
            font-size: 22px;
            text-shadow: 0px 0px 15px #00ffcc;
        }
        
        #gameHUD {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; 
            max-width: 900px; 
            margin: 10px auto;
            font-size: 16px;
            font-weight: bold;
            color: #00ffcc; 
            text-shadow: 0px 0px 10px #00ffcc;
            box-sizing: border-box;
            padding: 0 15px;
        }

        .game-wrapper {
            position: relative;
            width: 100%;
            max-width: 900px; 
            aspect-ratio: 16 / 9; 
            margin: 0 auto;
            border: 3px solid #00ffcc;
            border-radius: 10px;
            box-shadow: 0px 0px 60px rgba(0, 255, 204, 0.3);
            overflow: hidden;
            background-color: #050508; 
        }

        canvas { 
            display: block; 
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none; 
            z-index: 10;
        }

        .overlay-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.90);
            z-index: 20;
        }
        .overlay-box {
            background: rgba(10, 10, 15, 0.95);
            padding: 30px 50px;
            border: 3px solid #00ffcc;
            border-radius: 10px;
            box-shadow: 0px 0px 50px rgba(0, 255, 204, 0.5);
            text-align: center;
        }
        #gameOverScreen .overlay-box {
            border-color: #ff0000;
            box-shadow: 0px 0px 50px #ff0000;
        }
        .overlay-box h1 { font-size: 40px; margin-top: 0; letter-spacing: 2px; }
        #startScreen h1 { color: #00ffcc; text-shadow: 0px 0px 20px #00ffcc; }
        #gameOverScreen h1 { color: red; text-shadow: 0px 0px 20px red; }
        
        .btn-group { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
        .action-btn {
            background-color: #00ffcc; color: black; border: none; padding: 12px 20px;
            font-size: 16px; cursor: pointer; border-radius: 5px; font-weight: bold;
            text-transform: uppercase; transition: 0.2s;
        }
        .action-btn:hover { background-color: #fff; transform: scale(1.05); }
        .btn-easy { background-color: #00ffcc; }
        .btn-normal { background-color: #ffcc00; }
        .btn-hard { background-color: #ff0055; color: white; }

        #modeDisplay {
            background-color: #00ffcc; color: black; padding: 5px 15px; font-size: 14px;
            border-radius: 5px; font-weight: bold; transition: 0.3s;
        }
        #modeDisplay.manual {
            background-color: #ff00ff; color: white;
        }

        #gameInstructions {
            max-width: 900px; margin: 15px auto 0 auto;
            background: #111; border: 2px solid #333; border-radius: 10px;
            padding: 15px; text-align: left; line-height: 1.5; font-size: 14px;
            box-shadow: 0px 10px 30px rgba(0,0,0,0.8);
        }
        #gameInstructions h3 { color: #ffcc00; text-align: center; font-size: 18px; margin-top: 0; border-bottom: 2px solid #333; padding-bottom: 5px; }
        .highlight { color: #00ffcc; font-weight: bold; }
    </style>
</head>
<body>

    <div class="header-container">
        <div class="header-logo">üëΩüçÑ</div>
        <h2>THE SHROOM PROTECTOR</h2>
        <div class="header-logo">üçÑüëΩ</div>
    </div>

    <div id="gameHUD">
        <div id="hpDisplay" style="color: #00ff00;">üíö HP: 100</div>
        <div id="scoreDisplay">SCORE: 0</div>
        <div id="modeDisplay">ü§ñ AUTO</div>
        <div id="bombDisplay">üí• BOMBS: 1</div>
        <div id="levelDisplay">LVL: 1</div>
    </div>

    <div class="game-wrapper">
        <div class="scanlines"></div>
        <canvas id="gameCanvas" width="1280" height="720"></canvas>
        
        <div id="startScreen" class="overlay-screen">
            <div class="overlay-box">
                <h1>SYSTEM READY</h1>
                <p style="color: white; font-size: 18px;">Select Difficulty</p>
                <div class="btn-group">
                    <button class="action-btn btn-easy" onclick="startGame(0.7)">EASY</button>
                    <button class="action-btn btn-normal" onclick="startGame(1.0)">NORMAL</button>
                    <button class="action-btn btn-hard" onclick="startGame(1.5)">HARD</button>
                </div>
            </div>
        </div>

        <div id="gameOverScreen" class="overlay-screen" style="display: none;">
            <div class="overlay-box">
                <h1>YOU DIED</h1>
                <p style="color: white; font-size: 20px;">POINTS UPLOADING...<br><br>Final Score: <span id="finalScore" style="color:#00ffcc; font-weight:bold;">0</span></p>
                <button class="action-btn btn-easy" onclick="showStartScreen()">REBOOT SYSTEM</button>
            </div>
        </div>
    </div>

    <div id="gameInstructions">
        <h3>üçÑ COMMAND MANUAL üçÑ</h3>
        <p><span class="highlight">SURVIVE 30 LEVELS:</span> Watch your health! Grab dropping Medpacks (üè•) to regenerate.</p>
        <p><span class="highlight">CONTROLS:</span> Use 'M' for Manual (Move with Arrows, shoot with Spacebar) or 'A' for Auto-aiming.</p>
        <p><span class="highlight">BOSSES:</span> Spawn every 3 levels and shoot back! Dodge their attacks and use Bombs ('B') in an emergency.</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const bombDisplay = document.getElementById('bombDisplay');
        const modeDisplay = document.getElementById('modeDisplay');
        const hpDisplay = document.getElementById('hpDisplay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScore = document.getElementById('finalScore');

        // --- Audio System ---
        let audioCtx;
        let musicInterval;
        const arpeggioNotes = [261.63, 329.63, 392.00, 523.25, 392.00, 329.63]; 
        let currentNoteIndex = 0;

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playMusicNote() {
            if (!audioCtx || isGameOver || !gameStarted) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.type = 'square'; 
            osc.frequency.setValueAtTime(arpeggioNotes[currentNoteIndex], audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.02, audioCtx.currentTime); 
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc.connect(gainNode); gainNode.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.15);
            currentNoteIndex = (currentNoteIndex + 1) % arpeggioNotes.length;
        }

        function playPluckSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.type = 'sine'; 
            osc.frequency.setValueAtTime(450, audioCtx.currentTime); 
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            osc.connect(gainNode); gainNode.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        }

        function playHealSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        }

        function playDamageSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        }

        // --- Game Variables ---
        let animationId;
        let score = 0;
        let level = 1;
        let bombs = 1;
        let difficultyMultiplier = 1;
        let isGameOver = false;
        let gameStarted = false;
        let isSpawning = false; 
        let isAutoMode = true; 
        let lastShotTime = 0;

        let playerHp = 100;
        const playerMaxHp = 100;

        const player = { x: canvas.width / 2, y: canvas.height - 90, speed: 15 };
        const keys = { ArrowLeft: false, ArrowRight: false, Space: false };
        const levelColors = ['#00FF00', '#00FA33', '#00F566', '#00F099', '#00EBCC', '#00D6FF', '#00A3FF', '#0070FF', '#3333FF', '#6600FF', '#9900FF', '#CC00FF', '#FF00FF', '#FF00CC', '#FF0099', '#FF0066', '#FF0033', '#FF0000', '#CC0000', '#8B0000', '#660000', '#440000', '#FF4500', '#FF8C00', '#FFD700', '#ADFF2F', '#00FF7F', '#00CED1', '#1E90FF', '#FFFFFF'];

        let projectiles = [];
        let enemies = [];
        let enemyProjectiles = [];
        let medpacks = [];
        let activeBoss = null;
        let screenShake = 0;
        let stars = [];
        for (let i = 0; i < 200; i++) {
            stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 2 + 0.5, speed: Math.random() * 3 + 0.5, alpha: Math.random() });
        }

        // --- NEW: Function to sync points to the platform ---
        function syncScoreToPlayFun() {
            if (window.parent !== window) {
                // This sends the updated score to the website UI
                window.parent.postMessage({ type: 'SAVE_SCORE', score: Math.floor(score) }, '*');
                console.log("Points synced to Play.fun: " + Math.floor(score));
            }
        }

        // --- Controls ---
        window.addEventListener('keydown', (e) => {
            if (!gameStarted) return;
            if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
            if (e.code === 'ArrowRight') keys.ArrowRight = true;
            if (e.code === 'Space') { keys.Space = true; e.preventDefault(); }
            if ((e.code === 'KeyB' || e.key === 'b') && !isAutoMode) useBomb();
            if (e.code === 'KeyM' || e.key === 'm') setManualMode();
            if (e.code === 'KeyA' || e.key === 'a') setAutoMode();
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
            if (e.code === 'ArrowRight') keys.ArrowRight = false;
            if (e.code === 'Space') keys.Space = false;
        });

        function setManualMode() {
            if (isAutoMode) {
                isAutoMode = false;
                modeDisplay.innerText = "üïπÔ∏è MANUAL";
                modeDisplay.classList.add('manual');
            }
        }

        function setAutoMode() {
            if (!isAutoMode) {
                isAutoMode = true;
                modeDisplay.innerText = "ü§ñ AUTO";
                modeDisplay.classList.remove('manual');
            }
        }

        function hitPlayer(damage) {
            playerHp -= damage;
            screenShake = 10;
            playDamageSound();
            
            if (playerHp < 0) playerHp = 0;
            hpDisplay.innerText = `üíö HP: ${Math.floor(playerHp)}`;
            
            if (playerHp < 35) hpDisplay.style.color = 'red';
            else hpDisplay.style.color = '#00ff00';

            if (playerHp <= 0) endGame(false);
        }

        function drawStars() {
            stars.forEach(star => {
                star.y += star.speed; 
                if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; }
                ctx.fillStyle = `rgba(200, 255, 255, ${star.alpha})`;
                ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fill();
            });
        }

        function useBomb() {
            if (bombs > 0 && !isGameOver) {
                bombs--;
                bombDisplay.innerText = `üí• BOMBS: ${bombs}`;
                let visibleEnemies = enemies.filter(e => e.y > 0);
                score += visibleEnemies.length * 10 * difficultyMultiplier;
                enemies = []; 
                enemyProjectiles = []; 
                if (activeBoss && activeBoss.y > 0) activeBoss.hp -= 1500;
                
                ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height);
                scoreDisplay.innerText = "SCORE: " + Math.floor(score);
                screenShake = 15;
                checkLevelComplete();
            }
        }

        function shoot() {
            let beamWidth = 8 + (level * 1.5); 
            let beamLength = 50 + (level * 10); 
            let beamColor = levelColors[Math.min(level - 1, 29)];
            let damage = 20 + (level * 5); 

            projectiles.push({ type: 'laser', x: player.x, y: player.y - 40, width: beamWidth, height: beamLength, color: beamColor, velocityX: 0, velocityY: -25, damage: damage });
            playPluckSound();
            
            if (level >= 5) {
                projectiles.push({ type: 'laser', x: player.x - 30, y: player.y - 20, width: beamWidth/2, height: beamLength/1.5, color: beamColor, velocityX: 0, velocityY: -22, damage: damage/2 });
                projectiles.push({ type: 'laser', x: player.x + 30, y: player.y - 20, width: beamWidth/2, height: beamLength/1.5, color: beamColor, velocityX: 0, velocityY: -22, damage: damage/2 });
            }
            if (level >= 10) {
                let rocketDmg = 50 + (level * 10);
                projectiles.push({ type: 'rocket', x: player.x - 50, y: player.y, width: 10, height: 30, color: '#FF4500', velocityX: -4, velocityY: -12, damage: rocketDmg });
                projectiles.push({ type: 'rocket', x: player.x + 50, y: player.y, width: 10, height: 30, color: '#FF4500', velocityX: 4, velocityY: -12, damage: rocketDmg });
            }
            if (level >= 8) screenShake = 2;
        }

        function spawnWave() {
            isSpawning = true;
            if (level % 3 === 0) {
                let bossMultiplier = level / 3;
                let bossHP = (800 * bossMultiplier) * difficultyMultiplier;
                activeBoss = {
                    x: canvas.width / 2, y: -200, hp: bossHP, maxHp: bossHP,
                    width: 150 + (level * 5), height: 120 + (level * 5),
                    speedY: (0.15 + (level * 0.02)) * difficultyMultiplier, time: 0,
                    type: (level === 30) ? 'ufo' : 'alien',
                    lastShot: Date.now() 
                };
            } else {
                let enemyCount = Math.floor((4 + (level * 4)) * difficultyMultiplier); 
                let speed = (1.5 + (level * 0.15)) * difficultyMultiplier; 
                for (let i = 0; i < enemyCount; i++) {
                    enemies.push({ x: Math.random() * (canvas.width - 60) + 30, y: Math.random() * -1500 - 50, radius: 20 + (Math.random()*10), speed: speed });
                }
            }
            isSpawning = false;
        }

        function drawBoss() {
            if (!activeBoss) return;
            activeBoss.time += 0.05;
            activeBoss.x = (canvas.width / 2) + Math.sin(activeBoss.time) * (350 + (level*2)); 
            activeBoss.y += activeBoss.speedY;

            let bx = activeBoss.x, by = activeBoss.y, bw = activeBoss.width, bh = activeBoss.height;

            if (activeBoss.type === 'ufo') {
                ctx.fillStyle = "rgba(100, 200, 255, 0.4)";
                ctx.beginPath(); ctx.arc(bx, by - 20, bw/3, 0, Math.PI, true); ctx.fill(); 
                ctx.fillStyle = "#888";
                ctx.beginPath(); ctx.ellipse(bx, by, bw/1.5, bh/3, 0, 0, Math.PI * 2); ctx.fill(); 
                let lightColor = (Math.floor(activeBoss.time * 10) % 2 === 0) ? "red" : "cyan";
                ctx.fillStyle = lightColor; ctx.shadowBlur = 15; ctx.shadowColor = lightColor;
                ctx.beginPath(); ctx.arc(bx - bw/2, by, 10, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(bx + bw/2, by, 10, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(bx, by + 15, 15, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                let bossColor = `hsl(${(level * 40) % 360}, 70%, 40%)`; 
                ctx.fillStyle = bossColor; 
                ctx.beginPath(); ctx.ellipse(bx, by, bw/2, bh/2, 0, 0, Math.PI * 2); ctx.fill();
                ctx.lineWidth = 5; ctx.strokeStyle = "#222"; ctx.stroke();
                ctx.fillStyle = "#111";
                ctx.beginPath(); ctx.arc(bx - bw/3, by - bh/4, 15, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(bx + bw/4, by + bh/4, 20, 0, Math.PI*2); ctx.fill();
                let eyeGlow = Math.abs(Math.sin(activeBoss.time * 5)) * 10;
                ctx.fillStyle = "red"; ctx.shadowBlur = eyeGlow; ctx.shadowColor = "red";
                ctx.beginPath(); ctx.arc(bx - bw/4, by - 10, 15 + (level), 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(bx + bw/4, by - 10, 15 + (level), 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.moveTo(bx - bw/4, by + bh/4); ctx.lineTo(bx - bw/6, by + bh/2 + (level)); ctx.lineTo(bx, by + bh/4); 
                ctx.moveTo(bx, by + bh/4); ctx.lineTo(bx + bw/6, by + bh/2 + (level)); ctx.lineTo(bx + bw/4, by + bh/4); 
                ctx.fill();
            }

            if (activeBoss.y > 0) {
                let hpPercent = activeBoss.hp / activeBoss.maxHp;
                ctx.fillStyle = "red"; ctx.fillRect(bx - bw/2, by - bh/2 - 30, bw, 15);
                ctx.fillStyle = "#00ff00"; ctx.fillRect(bx - bw/2, by - bh/2 - 30, bw * hpPercent, 15);
                ctx.strokeStyle = "white"; ctx.strokeRect(bx - bw/2, by - bh/2 - 30, bw, 15);

                let attackRate = Math.max(400, 2000 - (level * 60)); 
                if (Date.now() - activeBoss.lastShot > attackRate) {
                    let projSpeed = (6 + (level * 0.3)) * difficultyMultiplier;
                    let projDmg = 15 + (level * 2);
                    
                    enemyProjectiles.push({ x: bx, y: by + bh/2, width: 10, height: 25, velocityX: 0, velocityY: projSpeed, damage: projDmg });
                    if (level >= 9) { 
                        enemyProjectiles.push({ x: bx - 40, y: by + bh/2, width: 10, height: 25, velocityX: -3, velocityY: projSpeed, damage: projDmg });
                        enemyProjectiles.push({ x: bx + 40, y: by + bh/2, width: 10, height: 25, velocityX: 3, velocityY: projSpeed, damage: projDmg });
                    }
                    activeBoss.lastShot = Date.now();
                }
            }

            if (activeBoss.y > canvas.height / 3) activeBoss.speedY = 0;
        }

        function drawPlayer() {
            let size = 25 + (Math.min(level, 30) * 1.5); 
            let shakeX = (Math.random() - 0.5) * screenShake;
            let shakeY = (Math.random() - 0.5) * screenShake;
            let pX = player.x + shakeX, pY = player.y + shakeY;
            let baseColor = levelColors[Math.min(level - 1, 29)];

            if (level >= 15) { ctx.shadowBlur = 20; ctx.shadowColor = baseColor; }

            ctx.fillStyle = '#cccccc'; ctx.strokeStyle = '#555555'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(pX - size/3, pY + size * 1.5); ctx.quadraticCurveTo(pX - size/4, pY, pX - size/6, pY - size/2); 
            ctx.lineTo(pX + size/6, pY - size/2); ctx.quadraticCurveTo(pX + size/4, pY, pX + size/3, pY + size * 1.5); ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.fillStyle = baseColor; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(pX - size * 1.4, pY + size/4); ctx.bezierCurveTo(pX - size * 1.4, pY - size * 1.5, pX + size * 1.4, pY - size * 1.5, pX + size * 1.4, pY + size/4); 
            ctx.bezierCurveTo(pX + size, pY + size/2, pX - size, pY + size/2, pX - size * 1.4, pY + size/4); ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.shadowBlur = 0; 

            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.beginPath(); ctx.ellipse(pX - size/2, pY - size/1.5, size/5, size/8, Math.PI/4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(pX + size/2, pY - size/2, size/4, size/6, -Math.PI/6, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(pX, pY - size, size/3, size/5, 0, 0, Math.PI*2); ctx.fill();

            let eyeTilt = Math.min(level * 1.5, 25); 
            ctx.fillStyle = "white";
            ctx.beginPath(); ctx.moveTo(pX - size/2, pY - size/5); ctx.lineTo(pX - size/6, pY + eyeTilt - size/6); ctx.lineTo(pX - size/2, pY + eyeTilt + 5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(pX + size/2, pY - size/5); ctx.lineTo(pX + size/6, pY + eyeTilt - size/6); ctx.lineTo(pX + size/2, pY + eyeTilt + 5); ctx.fill();

            ctx.fillStyle = "red"; ctx.shadowBlur = level; ctx.shadowColor = "red";
            ctx.beginPath(); ctx.arc(pX - size/4, pY + eyeTilt - size/10, 3 + (level*0.1), 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(pX + size/4, pY + eyeTilt - size/10, 3 + (level*0.1), 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.lineWidth = 3 + (level * 0.3); ctx.strokeStyle = "black";
            ctx.beginPath(); ctx.moveTo(pX - (size/1.2), pY - (size/3)); ctx.lineTo(pX - 2, pY + eyeTilt - (size/6)); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(pX + (size/1.2), pY - (size/3)); ctx.lineTo(pX + 2, pY + eyeTilt - (size/6)); ctx.stroke();

            ctx.fillStyle = "black"; ctx.beginPath();
            let mTop = pY + size/1.5, mBot = pY + size - 5 + (level); 
            ctx.moveTo(pX - size/2, mTop); ctx.lineTo(pX - size/4, mBot); ctx.lineTo(pX, mTop + 5);
            ctx.lineTo(pX + size/4, mBot); ctx.lineTo(pX + size/2, mTop); ctx.fill();
            
            if (screenShake > 0) screenShake -= 1;

            let hpRatio = Math.max(0, playerHp / playerMaxHp);
            ctx.fillStyle = "red"; ctx.fillRect(pX - 40, pY - size - 30, 80, 8);
            ctx.fillStyle = "#00ff00"; ctx.fillRect(pX - 40, pY - size - 30, 80 * hpRatio, 8);
            ctx.strokeStyle = "white"; ctx.lineWidth = 1; ctx.strokeRect(pX - 40, pY - size - 30, 80, 8);
        }

        // --- NEW: Sync score added to the level completion loop ---
        function checkLevelComplete() {
            if (enemies.length === 0 && !activeBoss && !isSpawning) {
                if (level >= 30) {
                    syncScoreToPlayFun(); // Sync points before winning
                    endGame(true); 
                    return;
                }
                isSpawning = true; 
                if (level % 2 === 0) {
                    bombs++;
                    bombDisplay.innerText = `üí• BOMBS: ${bombs}`;
                }
                level++;
                levelDisplay.innerText = (level === 30) ? `LVL: 30 (UFO)` : `LVL: ${level}`;
                if (level === 30) levelDisplay.style.color = "red";
                
                syncScoreToPlayFun(); // Syncs points to the platform immediately after passing the level!
                
                setTimeout(spawnWave, 1500); 
            }
            if (activeBoss && activeBoss.hp <= 0) {
                medpacks.push({ x: activeBoss.x, y: activeBoss.y, size: 25, velocityY: 3 });
                score += (1000 * level) * difficultyMultiplier;
                scoreDisplay.innerText = "SCORE: " + Math.floor(score);
                activeBoss = null;
                screenShake = 20;
                
                syncScoreToPlayFun(); // Sync points immediately after killing a boss!
                
                checkLevelComplete(); 
            }
        }

        function animate() {
            if (isGameOver || !gameStarted) return;
            animationId = requestAnimationFrame(animate);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars();

            let currentSpeed = player.speed + (level * 0.2); 
            let currentFireRate = Math.max(50, 150 - (level * 2)); 
            let pSize = 25 + (level * 1.5);

            if (isAutoMode) {
                let target = null;
                let visibleEnemies = enemies.filter(e => e.y > 0); 
                
                if (activeBoss && activeBoss.y > 0) target = activeBoss;
                else if (visibleEnemies.length > 0) {
                    target = visibleEnemies[0];
                    for(let i = 1; i < visibleEnemies.length; i++) {
                        if(visibleEnemies[i].y > target.y) target = visibleEnemies[i];
                    }
                }
                if (target) {
                    if (player.x < target.x - 5 && player.x + pSize * 1.5 < canvas.width) player.x += currentSpeed;
                    else if (player.x > target.x + 5 && player.x - pSize * 1.5 > 0) player.x -= currentSpeed;

                    if (Math.abs(player.x - target.x) < 80 + (level*2)) {
                        if (Date.now() - lastShotTime > currentFireRate) {
                            shoot();
                            lastShotTime = Date.now();
                        }
                    }
                }
            } else {
                if (keys.ArrowLeft && player.x - pSize * 1.5 > 0) player.x -= currentSpeed;
                if (keys.ArrowRight && player.x + pSize * 1.5 < canvas.width) player.x += currentSpeed;
                if (keys.Space && Date.now() - lastShotTime > currentFireRate) {
                    shoot();
                    lastShotTime = Date.now();
                }
            }
            
            drawBoss();
            drawPlayer();

            enemyProjectiles.forEach((p, index) => {
                p.x += p.velocityX; p.y += p.velocityY;
                ctx.fillStyle = "red"; ctx.shadowBlur = 10; ctx.shadowColor = "red";
                ctx.fillRect(p.x - p.width/2, p.y, p.width, p.height);
                ctx.shadowBlur = 0;

                if (p.y > canvas.height) {
                    enemyProjectiles.splice(index, 1);
                } else if (Math.hypot(player.x - p.x, player.y - p.y) < pSize + p.width) {
                    hitPlayer(p.damage);
                    enemyProjectiles.splice(index, 1);
                }
            });

            medpacks.forEach((m, index) => {
                m.y += m.velocityY;
                ctx.fillStyle = "white";
                ctx.fillRect(m.x - m.size/2, m.y - m.size/2, m.size, m.size);
                ctx.fillStyle = "red";
                ctx.fillRect(m.x - 3, m.y - m.size/2 + 2, 6, m.size - 4);
                ctx.fillRect(m.x - m.size/2 + 2, m.y - 3, m.size - 4, 6);
                
                if (m.y > canvas.height) {
                    medpacks.splice(index, 1);
                } else if (Math.hypot(player.x - m.x, player.y - m.y) < pSize + m.size) {
                    playerHp = Math.min(playerMaxHp, playerHp + 40);
                    hpDisplay.innerText = `üíö HP: ${Math.floor(playerHp)}`;
                    hpDisplay.style.color = '#00ff00';
                    playHealSound();
                    medpacks.splice(index, 1);
                }
            });

            projectiles.forEach((p, index) => {
                if (p.type === 'rocket') {
                    let visibleEnemies = enemies.filter(e => e.y > 0);
                    let target = (activeBoss && activeBoss.y > 0) ? activeBoss : (visibleEnemies.length > 0 ? visibleEnemies[0] : null);
                    if (target) {
                        if (target.x > p.x) p.velocityX += 0.8;
                        if (target.x < p.x) p.velocityX -= 0.8;
                    }
                    ctx.shadowBlur = 10; ctx.shadowColor = "orange"; ctx.fillStyle = "yellow";
                    ctx.fillRect(p.x - p.width/2 + 2, p.y + p.height, p.width - 4, 15);
                }

                p.x += p.velocityX; p.y += p.velocityY;
                ctx.shadowBlur = 15; ctx.shadowColor = p.color; ctx.fillStyle = "white"; 
                ctx.fillRect(p.x - p.width/2, p.y, p.width, p.height);
                ctx.strokeStyle = p.color; ctx.lineWidth = 4; ctx.strokeRect(p.x - p.width/2, p.y, p.width, p.height);
                ctx.shadowBlur = 0; 

                if (p.y + p.height < 0) projectiles.splice(index, 1);

                if (activeBoss && activeBoss.y > 0 && p.x > activeBoss.x - activeBoss.width/2 && p.x < activeBoss.x + activeBoss.width/2 && p.y < activeBoss.y + activeBoss.height/2) {
                    activeBoss.hp -= p.damage;
                    projectiles.splice(index, 1);
                    checkLevelComplete(); 
                }
            });

            enemies.forEach((enemy, eIndex) => {
                enemy.y += enemy.speed;
                ctx.font = "40px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText("üëΩ", enemy.x, enemy.y);

                if (enemy.y > canvas.height) {
                    hitPlayer(10); 
                    enemies.splice(eIndex, 1);
                    checkLevelComplete();
                } else if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < pSize + 15) {
                    hitPlayer(25); 
                    enemies.splice(eIndex, 1);
                    checkLevelComplete();
                }

                projectiles.forEach((p, pIndex) => {
                    if (enemy.y > 0 && p.x > enemy.x - 25 && p.x < enemy.x + 25 && p.y < enemy.y + 25 && p.y + p.height > enemy.y - 25) {
                        if (Math.random() < 0.08) medpacks.push({ x: enemy.x, y: enemy.y, size: 20, velocityY: 3 });

                        enemies.splice(eIndex, 1);
                        if (p.type !== 'rocket') projectiles.splice(pIndex, 1); 
                        score += 10 * difficultyMultiplier;
                        scoreDisplay.innerText = "SCORE: " + Math.floor(score);
                        checkLevelComplete();
                    }
                });
            });
        }

        // --- NEW: Sync score added to game over/win screen ---
        function endGame(victory = false) {
            isGameOver = true;
            clearInterval(musicInterval); 
            gameOverScreen.style.display = 'flex';
            
            if (victory) {
                gameOverScreen.querySelector('h1').innerText = "UNIVERSE SAVED!";
                gameOverScreen.querySelector('h1').style.color = "#00ffcc";
            } else {
                gameOverScreen.querySelector('h1').innerText = "YOU DIED";
                gameOverScreen.querySelector('h1').style.color = "red";
            }
            
            finalScore.innerText = Math.floor(score);
            syncScoreToPlayFun(); // Final sync sent when the game ends
        }

        function showStartScreen() {
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
        }

        function startGame(selectedDifficulty) {
            initAudio(); 
            difficultyMultiplier = selectedDifficulty;
            gameStarted = true;
            isGameOver = false;
            isSpawning = false;
            isAutoMode = true;
            screenShake = 0;
            score = 0;
            level = 1;
            bombs = 1;
            playerHp = 100;
            
            player.x = canvas.width / 2;
            projectiles = [];
            enemyProjectiles = [];
            enemies = [];
            medpacks = [];
            activeBoss = null;
            
            scoreDisplay.innerText = "SCORE: 0";
            levelDisplay.innerText = "LVL: 1";
            levelDisplay.style.color = "#00ffcc";
            hpDisplay.innerText = "üíö HP: 100";
            hpDisplay.style.color = "#00ff00";
            bombDisplay.innerText = `üí• BOMBS: 1`;
            
            modeDisplay.innerText = "ü§ñ AUTO";
            modeDisplay.classList.remove('manual');

            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            
            clearInterval(musicInterval);
            musicInterval = setInterval(playMusicNote, 150);

            spawnWave();
            animate();
        }

        drawStars();

    </script>
</body>
</html>
