<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Shroom Protector</title>
    <meta name="x-ogp-key" content="657c89e6-1d39-472f-aa21-b6ef8dc732ff" id="ogp-key-meta" />
    
    <script src="https://sdk.play.fun/sdk.js"></script>

    <style>
        body { 
            margin: 0; background-color: #020202; color: #00ffcc; 
            font-family: 'Courier New', Courier, monospace; text-align: center; 
            overflow: hidden; 
        }
        
        .header-container { display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 10px; margin-bottom: 5px; }
        .header-logo { font-size: 25px; text-shadow: 0px 0px 20px #00ffcc; filter: drop-shadow(0px 0px 10px rgba(0, 255, 204, 0.8)); }
        h2 { margin: 0; color: #00ffcc; letter-spacing: 3px; text-shadow: 0px 0px 10px #00ffcc; font-size: 22px;}
        
        #gameHUD { 
            display: flex; justify-content: space-between; align-items: center; 
            max-width: 1000px; width: 95%; margin: 5px auto; font-size: 16px; 
            font-weight: bold; color: #00ffcc; text-shadow: 0px 0px 10px #00ffcc; 
        }
        
        .hp-container { width: 30%; max-width: 250px; height: 20px; border: 2px solid #fff; border-radius: 5px; background: #330000; position: relative; overflow: hidden;}
        #hpFill { height: 100%; width: 100%; background: #00ff00; transition: width 0.2s, background-color 0.2s; box-shadow: 0px 0px 10px #00ff00; }
        .hp-text { position: absolute; top: 1px; left: 0; width: 100%; text-align: center; color: white; font-size: 14px; text-shadow: 1px 1px 2px black; z-index: 2; }

        .game-wrapper { 
            position: relative; max-width: 1000px; width: 95%; max-height: 65vh; aspect-ratio: 16 / 9; 
            margin: 0 auto; border: 3px solid #00ffcc; border-radius: 10px; 
            box-shadow: 0px 0px 60px rgba(0, 255, 204, 0.4); overflow: hidden; background-color: #050508; 
        }
        
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        
        .scanlines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 4px, 3px 100%; pointer-events: none; z-index: 10; }
        
        .command-guide { max-width: 1000px; width: 95%; margin: 10px auto; padding: 10px; border: 1px solid #00ffcc; background: rgba(0, 255, 204, 0.1); border-radius: 5px; color: #fff; font-size: 14px; display: flex; justify-content: space-around; text-shadow: 0px 0px 5px #00ffcc;}
        .highlight { color: #ff00ff; font-weight: bold; text-shadow: 0px 0px 8px #ff00ff;}

        #startOverlay, #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; }
        #gameOverScreen { display: none; border: 4px solid #ff0000; box-shadow: inset 0px 0px 50px #ff0000; }
        
        .btn-start { background: #00ffcc; color: #000; border: none; padding: 20px 50px; font-size: 30px; font-weight: bold; cursor: pointer; border-radius: 10px; box-shadow: 0 0 20px #00ffcc; transition: 0.3s; }
        .btn-start:hover { transform: scale(1.1); background: #fff; box-shadow: 0 0 40px #fff; }

        #modeDisplay { background-color: #00ffcc; color: black; padding: 3px 15px; font-size: 14px; border-radius: 5px; font-weight: bold; box-shadow: 0px 0px 10px #00ffcc; min-width: 120px; }
        #modeDisplay.manual { background-color: #ff00ff; box-shadow: 0px 0px 10px #ff00ff; color: white; }
        
        .reboot-btn { background-color: #ff0000; color: white; border: none; padding: 15px 30px; font-size: 20px; cursor: pointer; border-radius: 5px; font-weight: bold; margin-top: 15px; }
        .reboot-btn:hover { background-color: #cc0000; }
    </style>
</head>
<body>

    <div class="header-container">
        <div class="header-logo">üëΩüçÑ</div>
        <h2>THE SHROOM PROTECTOR</h2>
        <div class="header-logo">üçÑüëΩ</div>
    </div>

    <div id="gameHUD">
        <div id="scoreDisplay">Score: 0</div>
        <div class="hp-container"><div id="hpFill"></div><div class="hp-text" id="hpText">HULL: 100%</div></div>
        <div id="modeDisplay">ü§ñ AUTO</div>
        <div id="bombDisplay">üí• Bombs: 1</div>
        <div id="levelDisplay">Level: 1</div>
    </div>

    <div class="game-wrapper">
        <div id="startOverlay">
            <h1 style="color:#00ffcc; font-size: 45px; margin-bottom: 20px; text-shadow: 0 0 20px #00ffcc;">SYSTEM READY</h1>
            <p style="color:white; margin-bottom: 30px;">Awaiting Deployment...</p>
            <button class="btn-start" onclick="startGame()">START DEFENSE</button>
        </div>
        
        <div class="scanlines"></div>
        <canvas id="gameCanvas" width="1200" height="675"></canvas>
        
        <div id="gameOverScreen">
            <h1 id="endTitle" style="color: red; font-size: 45px; margin-top: 0; text-shadow: 0px 0px 20px red;">HULL DESTROYED</h1>
            <p style="color: white; font-size: 24px;">Final Score: <span id="finalScore">0</span></p>
            <button class="reboot-btn" onclick="restartGame()">REBOOT PROTECTOR</button>
        </div>
    </div>

    <div class="command-guide">
        <span><span class="highlight">MODE:</span> 'M' for Manual / 'A' for Auto</span>
        <span><span class="highlight">MOVE:</span> Left & Right Arrows</span>
        <span><span class="highlight">ATTACK:</span> Spacebar</span>
        <span><span class="highlight">BOMB:</span> 'B'</span>
    </div>

    <script>
        // --- 2. CREATE SDK INSTANCE & INITIALIZE ---
        let ogp = null;
        try {
            if (typeof OpenGameSDK !== 'undefined') {
                ogp = new OpenGameSDK();
                ogp.init({ gameId: '87a38bcf-15f2-4524-ab5a-3e1253415e45' });
            }
        } catch (e) {
            console.log("Play.fun SDK initialization error.");
        }

        // --- GLOBAL POINTS HANDLER ---
        let score = 0;
        function recordPoints(pts) {
            score += pts;
            document.getElementById('scoreDisplay').innerText = "Score: " + score;
            
            // 3. CALL addPoints() DURING GAMEPLAY
            if (pts > 0 && ogp && typeof ogp.addPoints === 'function') {
                try {
                    ogp.addPoints(pts);
                } catch (error) {
                    console.log("Play.fun SDK point sync pending...");
                }
            }
        }

        // --- CATCHY 8-BIT AUDIO ENGINE ---
        let audioCtx;
        let musicInterval;

        function initAudio() {
            try {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') audioCtx.resume();
            } catch(e) { console.log("Audio not supported"); }
        }

        function playRetroMusic() {
            if (musicInterval) clearInterval(musicInterval);
            const notes = [45, 45, 48, 45, 52, 45, 50, 48];
            let step = 0;
            
            musicInterval = setInterval(() => {
                try {
                    if(!audioCtx || isGameOver) return;
                    let time = audioCtx.currentTime;

                    let osc1 = audioCtx.createOscillator();
                    let osc2 = audioCtx.createOscillator();
                    let gain = audioCtx.createGain();
                    
                    osc1.type = 'square';
                    osc1.frequency.value = 440 * Math.pow(2, (notes[step] - 69) / 12);
                    osc2.type = 'triangle'; 
                    osc2.frequency.value = (440 * Math.pow(2, (notes[step] - 69) / 12)) / 2;
                    
                    osc1.connect(gain);
                    osc2.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    gain.gain.setValueAtTime(0.04, time); 
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
                    
                    osc1.start(time); osc1.stop(time + 0.1);
                    osc2.start(time); osc2.stop(time + 0.1);

                    if (step % 4 === 0) {
                        let kickOsc = audioCtx.createOscillator();
                        let kickGain = audioCtx.createGain();
                        kickOsc.connect(kickGain);
                        kickGain.connect(audioCtx.destination);
                        
                        kickOsc.frequency.setValueAtTime(150, time);
                        kickOsc.frequency.exponentialRampToValueAtTime(0.001, time + 0.1);
                        
                        kickGain.gain.setValueAtTime(0.2, time);
                        kickGain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
                        
                        kickOsc.start(time); kickOsc.stop(time + 0.1);
                    }

                    if (step % 4 === 2) {
                        let hatOsc = audioCtx.createOscillator();
                        let hatGain = audioCtx.createGain();
                        hatOsc.type = 'square';
                        hatOsc.connect(hatGain);
                        hatGain.connect(audioCtx.destination);
                        
                        hatOsc.frequency.setValueAtTime(8000, time); 
                        hatGain.gain.setValueAtTime(0.015, time); 
                        hatGain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                        
                        hatOsc.start(time); hatOsc.stop(time + 0.05);
                    }

                    step = (step + 1) % notes.length;
                } catch(e) {}
            }, 140); 
        }

        // FIXED: The browser crash bug was here! Safely reuses the existing audioCtx.
        function playShootSFX() {
            try {
                if(!audioCtx) return;
                let o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'sawtooth';
                o.frequency.setValueAtTime(880, audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.15); 
                o.connect(g); g.connect(audioCtx.destination);
                g.gain.setValueAtTime(0.08, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
                o.start(); o.stop(audioCtx.currentTime + 0.15);
            } catch(e) {}
        }

        function playExplosionSFX() {
            try {
                if(!audioCtx) return;
                let o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'square'; 
                o.frequency.setValueAtTime(100, audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                o.connect(g); g.connect(audioCtx.destination);
                g.gain.setValueAtTime(0.15, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                o.start(); o.stop(audioCtx.currentTime + 0.2);
            } catch(e) {}
        }


        // --- CORE GAME ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let animationId, level = 1, bombs = 1, isGameOver = false, isSpawning = false, isAutoMode = true;
        let lastShotTime = 0, lastHeadRocketTime = 0, bossAlertText = "", bossAlertTimer = 0;
        let survivalPointTimer; 

        const player = { x: canvas.width / 2, y: canvas.height - 70, speed: 12, hp: 100, maxHp: 100, invulnTimer: 0 };
        const keys = { ArrowLeft: false, ArrowRight: false, Space: false };
        let projectiles = [], enemies = [], bossProjectiles = [], particles = [], activeBoss = null, screenShake = 0, stars = [];
        
        for (let i = 0; i < 150; i++) {
            stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 2 + 0.5, speed: Math.random() * 3 + 0.5, alpha: Math.random() });
        }

        function startGame() {
            document.getElementById('startOverlay').style.display = 'none';
            initAudio();
            playRetroMusic(); 
            spawnWave();
            updateHP();
            
            // IDLE COIN MINER - Safely pumps 5 points every 1 second into the Play.fun Widget
            if (survivalPointTimer) clearInterval(survivalPointTimer);
            survivalPointTimer = setInterval(() => {
                if (!isGameOver) {
                    recordPoints(5); 
                }
            }, 1000); 
            
            animate();
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
            if (e.code === 'ArrowRight') keys.ArrowRight = true;
            if (e.code === 'Space') { keys.Space = true; e.preventDefault(); }
            if ((e.code === 'KeyB' || e.key === 'b') && !isAutoMode) useBomb();
            if (e.code === 'KeyM' || e.key === 'm') { isAutoMode = false; document.getElementById('modeDisplay').innerText = "üïπÔ∏è MANUAL"; document.getElementById('modeDisplay').classList.add('manual'); }
            if (e.code === 'KeyA' || e.key === 'a') { isAutoMode = true; document.getElementById('modeDisplay').innerText = "ü§ñ AUTO"; document.getElementById('modeDisplay').classList.remove('manual'); }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
            if (e.code === 'ArrowRight') keys.ArrowRight = false;
            if (e.code === 'Space') keys.Space = false;
        });

        function updateHP() {
            let pct = Math.max(0, (player.hp / player.maxHp) * 100);
            document.getElementById('hpFill').style.width = pct + "%";
            document.getElementById('hpText').innerText = `HULL: ${Math.ceil(pct)}%`;
            if (pct > 60) document.getElementById('hpFill').style.background = "#00ff00";
            else if (pct > 30) document.getElementById('hpFill').style.background = "#ffff00";
            else document.getElementById('hpFill').style.background = "#ff0000";
            if (player.hp <= 0 && !isGameOver) endGame();
        }

        const levelColors = ['#00FF00', '#00FA33', '#00F566', '#00F099', '#00EBCC', '#00D6FF', '#00A3FF', '#0070FF', '#3333FF', '#6600FF', '#9900FF', '#CC00FF', '#FF00FF', '#FF00CC', '#FF0099', '#FF0066', '#FF0033', '#FF0000', '#CC0000', '#8B0000'];

        function createExplosion(x, y, color, amount) {
            playExplosionSFX();
            for(let i=0; i<amount; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15, life: 1.0, color: color, size: Math.random()*5+2 });
        }

        function useBomb() {
            if (bombs > 0 && !isGameOver) {
                bombs--; document.getElementById('bombDisplay').innerText = `üí• Bombs: ${bombs}`;
                let visibleEnemies = enemies.filter(e => e.y > 0);
                
                recordPoints(visibleEnemies.length * 10);

                enemies = []; bossProjectiles = [];
                if (activeBoss && activeBoss.y > 0) { activeBoss.hp -= 1500; createExplosion(activeBoss.x, activeBoss.y, "orange", 50); }
                ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height);
                checkLevelComplete();
            }
        }

        function shoot() {
            playShootSFX();
            let bw = 8 + (level * 2), bl = 50 + (level * 15), dmg = 25 + (level * 10), c = levelColors[Math.min(level - 1, 19)];
            projectiles.push({ type: 'laser', x: player.x, y: player.y - 40, width: bw, height: bl, color: c, velocityX: 0, velocityY: -25, damage: dmg });
            if (level >= 5) {
                projectiles.push({ type: 'laser', x: player.x - 30, y: player.y - 20, width: bw/2, height: bl/1.5, color: c, velocityX: 0, velocityY: -22, damage: dmg/2 });
                projectiles.push({ type: 'laser', x: player.x + 30, y: player.y - 20, width: bw/2, height: bl/1.5, color: c, velocityX: 0, velocityY: -22, damage: dmg/2 });
            }
            if (level >= 4) {
                projectiles.push({ type: 'rocket', x: player.x - 50, y: player.y, width: 10, height: 30, color: '#FF4500', velocityX: -4, velocityY: -12, damage: 100+(level*20) });
                projectiles.push({ type: 'rocket', x: player.x + 50, y: player.y, width: 10, height: 30, color: '#FF4500', velocityX: 4, velocityY: -12, damage: 100+(level*20) });
            }
            if (level >= 8) screenShake = 5;
        }

        function fireHeadRocket() {
            if (level >= 5 && !isGameOver) {
                let target = (activeBoss && activeBoss.y > 0) ? activeBoss : (enemies.length > 0 ? enemies[0] : null);
                if (target) {
                    projectiles.push({ type: 'heavy_rocket', x: player.x, y: player.y - 80, width: 18, height: 45, color: '#FFFFFF', velocityX: 0, velocityY: -15, damage: 400 + (level * 50) });
                    screenShake = 10; 
                }
            }
        }

        const bossData = {
            3: { name: "THE SLUDGE MOUTH", hp: 2000, color: "#4a5d23", shape: "blob", atkRate: 2000, speed: 0.3 },
            6: { name: "CRIMSON WATCHER", hp: 4500, color: "#8B0000", shape: "diamond", atkRate: 1500, speed: 0.4 },
            9: { name: "TOXIC SWARM LORD", hp: 8000, color: "#660099", shape: "insect", atkRate: 1200, speed: 0.5 },
            12: { name: "MECHA-SPORE", hp: 12000, color: "#557788", shape: "robot", atkRate: 900, speed: 0.55 },
            15: { name: "VOID GOLIATH", hp: 17000, color: "#111111", shape: "crystal", atkRate: 700, speed: 0.6 },
            18: { name: "ELDER ABOMINATION", hp: 25000, color: "#994400", shape: "tentacles", atkRate: 500, speed: 0.7 },
            20: { name: "MOTHERSHIP OMEGA", hp: 50000, color: "#cccccc", shape: "ufo", atkRate: 300, speed: 0.3 }
        };

        function spawnWave() {
            isSpawning = true;
            if ((level % 3 === 0 && level < 20) || level === 20) {
                let b = bossData[level] || bossData[3];
                activeBoss = { ...b, levelType: level, x: canvas.width / 2, y: -250, maxHp: b.hp, width: 180+(level*10), height: 140+(level*10), time: 0, lastAtk: Date.now() };
                bossAlertText = activeBoss.name; bossAlertTimer = 150; 
            } else {
                for (let i = 0; i < 6 + (level * 4); i++) enemies.push({ x: Math.random() * (canvas.width - 60) + 30, y: Math.random() * -1200 - 50, radius: 22, speed: 1.5 + (level * 0.2) });
            }
            isSpawning = false;
        }

        function drawBoss() {
            if (!activeBoss) return;
            activeBoss.time += 0.05;
            let sway = activeBoss.levelType === 20 ? 450 : 350;
            activeBoss.x = (canvas.width / 2) + Math.sin(activeBoss.time) * sway;
            if (activeBoss.y < 150) activeBoss.y += activeBoss.speed; 

            let bx = activeBoss.x, by = activeBoss.y, bw = activeBoss.width, bh = activeBoss.height;

            ctx.fillStyle = activeBoss.color; ctx.lineWidth = 4; ctx.strokeStyle = "#fff"; ctx.beginPath();
            
            if (activeBoss.shape === "blob") {
                ctx.ellipse(bx, by, bw/2, bh/2, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.fillStyle="black"; ctx.ellipse(bx, by+20, bw/3, bh/4, 0, 0, Math.PI*2); ctx.fill(); 
            } else if (activeBoss.shape === "diamond") {
                ctx.moveTo(bx, by - bh/2); ctx.lineTo(bx + bw/2, by); ctx.lineTo(bx, by + bh/2); ctx.lineTo(bx - bw/2, by); ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.fillStyle="red"; ctx.beginPath(); ctx.arc(bx, by, 30, 0, Math.PI*2); ctx.fill(); 
            } else if (activeBoss.shape === "insect") {
                ctx.arc(bx, by - bh/3, bw/3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.arc(bx - bw/4, by + bh/4, bw/4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.arc(bx + bw/4, by + bh/4, bw/4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.fillStyle="lime"; ctx.beginPath(); ctx.arc(bx-bw/4, by+bh/4, 15,0,Math.PI*2); ctx.arc(bx+bw/4, by+bh/4, 15,0,Math.PI*2); ctx.fill();
            } else if (activeBoss.shape === "robot") {
                ctx.fillRect(bx - bw/2, by - bh/2, bw, bh); ctx.strokeRect(bx - bw/2, by - bh/2, bw, bh);
                ctx.fillStyle="#00ffff"; ctx.fillRect(bx-bw/3, by-bh/4, bw/1.5, bh/4); 
            } else if (activeBoss.shape === "crystal") {
                for(let i=0; i<8; i++){ let ang = (i * Math.PI) / 4; let out = (i%2===0)? bw/2 : bw/4; ctx.lineTo(bx + Math.cos(ang)*out, by + Math.sin(ang)*out); }
                ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.fillStyle="#ff00ff"; ctx.beginPath(); ctx.arc(bx, by, 25, 0, Math.PI*2); ctx.fill();
            } else if (activeBoss.shape === "tentacles") {
                ctx.ellipse(bx, by, bw/2.5, bh/2.5, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.strokeStyle = activeBoss.color; ctx.lineWidth = 15;
                for(let i=-2; i<=2; i++){
                    ctx.beginPath(); ctx.moveTo(bx + (i*30), by+20);
                    ctx.quadraticCurveTo(bx + (i*50) + Math.sin(activeBoss.time*2)*50, by + bh, bx + (i*40), by + bh + 100); ctx.stroke();
                }
            } else if (activeBoss.shape === "ufo") {
                ctx.ellipse(bx, by, bw/1.5, bh/3, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = "rgba(0, 255, 255, 0.4)"; ctx.beginPath(); ctx.arc(bx, by - bh/4, bw/4, Math.PI, 0); ctx.fill(); ctx.stroke();
            }

            if (activeBoss.y > 0) {
                ctx.fillStyle = "red"; ctx.fillRect(bx - bw/2, by - bh/2 - 40, bw, 20);
                ctx.fillStyle = "#00ff00"; ctx.fillRect(bx - bw/2, by - bh/2 - 40, bw * Math.max(0, activeBoss.hp / activeBoss.maxHp), 20);
                ctx.strokeStyle = "white"; ctx.strokeRect(bx - bw/2, by - bh/2 - 40, bw, 20);

                if (Date.now() - activeBoss.lastAtk > bossData[level].atkRate) {
                    let bDmg = 15 + (level * 2);
                    bossProjectiles.push({ x: bx, y: by + bh/2, vx: 0, vy: 10 + (level*0.5), size: 15, dmg: bDmg });
                    if (level >= 9) {
                        bossProjectiles.push({ x: bx, y: by + bh/2, vx: -4, vy: 9 + (level*0.5), size: 15, dmg: bDmg });
                        bossProjectiles.push({ x: bx, y: by + bh/2, vx: 4, vy: 9 + (level*0.5), size: 15, dmg: bDmg });
                    }
                    if (level === 20) {
                        bossProjectiles.push({ x: bx, y: by + bh/2, vx: -8, vy: 8, size: 20, dmg: bDmg });
                        bossProjectiles.push({ x: bx, y: by + bh/2, vx: 8, vy: 8, size: 20, dmg: bDmg });
                    }
                    activeBoss.lastAtk = Date.now();
                }
            }
        }

        function drawPlayer() {
            let size = 25 + (Math.min(level, 20) * 2.5); 
            let shakeX = (Math.random() - 0.5) * screenShake, shakeY = (Math.random() - 0.5) * screenShake;
            let pX = player.x + shakeX, pY = player.y + shakeY;
            let baseColor = levelColors[Math.min(level - 1, 19)];

            if (player.invulnTimer > 0) { player.invulnTimer--; if (player.invulnTimer % 10 < 5) return; }

            if (level >= 5) {
                ctx.fillStyle = "#555"; ctx.strokeStyle = "#ccc"; ctx.lineWidth = 2;
                ctx.fillRect(pX - 12, pY - size - 25, 24, 30); 
                ctx.strokeRect(pX - 12, pY - size - 25, 24, 30);
                ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(pX, pY - size - 25, 8, Math.PI, 0); ctx.fill();
            }

            ctx.fillStyle = '#cccccc'; ctx.strokeStyle = '#555555'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(pX - size/3, pY + size * 1.5); ctx.quadraticCurveTo(pX - size/4, pY, pX - size/6, pY - size/2); 
            ctx.lineTo(pX + size/6, pY - size/2); ctx.quadraticCurveTo(pX + size/4, pY, pX + size/3, pY + size * 1.5); ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.fillStyle = baseColor; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(pX - size * 1.4, pY + size/4); ctx.bezierCurveTo(pX - size * 1.4, pY - size * 1.5, pX + size * 1.4, pY - size * 1.5, pX + size * 1.4, pY + size/4); 
            ctx.bezierCurveTo(pX + size, pY + size/2, pX - size, pY + size/2, pX - size * 1.4, pY + size/4); ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.beginPath(); ctx.ellipse(pX - size/2, pY - size/1.5, size/5, size/8, Math.PI/4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(pX + size/2, pY - size/2, size/4, size/6, -Math.PI/6, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(pX, pY - size, size/3, size/5, 0, 0, Math.PI*2); ctx.fill();

            let eyeTilt = level * 1.2; 
            ctx.fillStyle = "white";
            ctx.beginPath(); ctx.moveTo(pX - size/2, pY - size/5); ctx.lineTo(pX - size/6, pY + eyeTilt - size/6); ctx.lineTo(pX - size/2, pY + eyeTilt + 5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(pX + size/2, pY - size/5); ctx.lineTo(pX + size/6, pY + eyeTilt - size/6); ctx.lineTo(pX + size/2, pY + eyeTilt + 5); ctx.fill();
            ctx.fillStyle = "red";
            ctx.beginPath(); ctx.arc(pX - size/4, pY + eyeTilt - size/10, 3 + (level*0.2), 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(pX + size/4, pY + eyeTilt - size/10, 3 + (level*0.2), 0, Math.PI*2); ctx.fill();
            ctx.lineWidth = 3 + (level * 0.4); ctx.strokeStyle = "black";
            ctx.beginPath(); ctx.moveTo(pX - (size/1.2), pY - (size/3)); ctx.lineTo(pX - 2, pY + eyeTilt - (size/6)); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(pX + (size/1.2), pY - (size/3)); ctx.lineTo(pX + 2, pY + eyeTilt - (size/6)); ctx.stroke();

            ctx.fillStyle = "black"; ctx.beginPath();
            let mTop = pY + size/1.5, mBot = pY + size - 5 + (level*1.5); 
            ctx.moveTo(pX - size/2, mTop); ctx.lineTo(pX - size/4, mBot); ctx.lineTo(pX, mTop + 5);
            ctx.lineTo(pX + size/4, mBot); ctx.lineTo(pX + size/2, mTop); ctx.fill();
            
            if (screenShake > 0) screenShake -= 1;
        }

        function takeDamage(amt) {
            if (player.invulnTimer <= 0) {
                player.hp -= amt; player.invulnTimer = 60; screenShake = 20;
                ctx.fillStyle = "rgba(255,0,0,0.5)"; ctx.fillRect(0,0,canvas.width,canvas.height);
                createExplosion(player.x, player.y, "#00ff00", 30); updateHP();
            }
        }

        function checkLevelComplete() {
            if (enemies.length === 0 && !activeBoss && !isSpawning) {
                isSpawning = true; if (level % 2 === 0) bombs++;
                document.getElementById('bombDisplay').innerText = `üí• Bombs: ${bombs}`;
                player.hp = Math.min(player.maxHp, player.hp + 20); updateHP();
                if (level === 20) { document.getElementById('endTitle').innerText = "EARTH SECURED!"; document.getElementById('endTitle').style.color = "#00ffcc"; endGame(); return; }
                level++; document.getElementById('levelDisplay').innerText = `Level: ${level}`; setTimeout(spawnWave, 2000); 
            }
            if (activeBoss && activeBoss.hp <= 0) {
                createExplosion(activeBoss.x, activeBoss.y, activeBoss.color, 200);
                recordPoints((activeBoss.levelType === 20) ? 50000 : 2000 * level);
                activeBoss = null; bossProjectiles = []; checkLevelComplete(); 
            }
        }

        function animate() {
            if (isGameOver) return;
            animationId = requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            stars.forEach(s => { 
                s.y += s.speed; 
                if (s.y > canvas.height) { s.y = 0; s.x = Math.random() * canvas.width; } 
                ctx.fillStyle = `rgba(200, 255, 255, ${s.alpha})`; 
                ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2); ctx.fill(); 
            });

            for(let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.03;
                if(p.life <= 0) { particles.splice(i, 1); continue; }
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0;
            }

            if (level >= 5 && Date.now() - lastHeadRocketTime > 5000) { fireHeadRocket(); lastHeadRocketTime = Date.now(); }

            let spd = player.speed + (level * 0.4), fireRate = 120, pSize = 25 + (level * 2.5);

            if (isAutoMode) {
                let t = (activeBoss && activeBoss.y > 0) ? activeBoss : (enemies.filter(e => e.y > 0)[0] || null);
                let dodging = false;
                for (let bp of bossProjectiles) {
                    if (bp.y > player.y - 250 && Math.abs(bp.x - player.x) < 50) {
                        dodging = true;
                        if (bp.x > player.x && player.x - pSize > 0) player.x -= spd;
                        else if (player.x + pSize < canvas.width) player.x += spd;
                        break; 
                    }
                }
                if (!dodging && t && spd > 0) {
                    if (player.x < t.x - 5 && player.x + pSize * 1.5 < canvas.width) player.x += spd;
                    else if (player.x > t.x + 5 && player.x - pSize * 1.5 > 0) player.x -= spd;
                    if (Math.abs(player.x - t.x) < 80 + (level*5) && Date.now() - lastShotTime > fireRate) { shoot(); lastShotTime = Date.now(); }
                }
            } else {
                if (keys.ArrowLeft && player.x - pSize * 1.5 > 0) player.x -= spd;
                if (keys.ArrowRight && player.x + pSize * 1.5 < canvas.width) player.x += spd;
                if (keys.Space && Date.now() - lastShotTime > fireRate) { shoot(); lastShotTime = Date.now(); }
            }
            
            drawBoss();
            drawPlayer();

            if (bossAlertTimer > 0) { ctx.fillStyle = `rgba(255, 0, 0, ${Math.min(bossAlertTimer / 50, 1)})`; ctx.font = "bold 60px Courier New"; ctx.textAlign = "center"; ctx.fillText(`üö® WARNING: ${bossAlertText} üö®`, canvas.width/2, canvas.height/2); bossAlertTimer--; }

            for(let i = bossProjectiles.length - 1; i >= 0; i--) {
                let bp = bossProjectiles[i]; bp.x += bp.vx; bp.y += bp.vy;
                ctx.fillStyle = "#ff3300"; ctx.beginPath(); ctx.arc(bp.x, bp.y, bp.size, 0, Math.PI*2); ctx.fill();
                if (Math.hypot(player.x - bp.x, player.y - bp.y) < pSize + bp.size) { takeDamage(bp.dmg); bossProjectiles.splice(i, 1); continue; }
                if (bp.y > canvas.height) bossProjectiles.splice(i, 1);
            }

            projectiles.forEach((p, index) => {
                if (p.type === 'rocket' || p.type === 'heavy_rocket') {
                    let target = (activeBoss && activeBoss.y > 0) ? activeBoss : (enemies.filter(e => e.y > 0)[0] || null);
                    if (target) {
                        let trackingSpeed = p.type === 'heavy_rocket' ? 1.5 : 0.8; 
                        if (target.x > p.x) p.velocityX += trackingSpeed;
                        if (target.x < p.x) p.velocityX -= trackingSpeed;
                    }
                    ctx.fillStyle = "yellow"; ctx.fillRect(p.x - p.width/2 + 2, p.y + p.height, p.width - 4, p.type==='heavy_rocket' ? 25 : 15);
                }

                p.x += p.velocityX; p.y += p.velocityY;
                ctx.fillStyle = "white"; ctx.fillRect(p.x - p.width/2, p.y, p.width, p.height);
                ctx.strokeStyle = p.color; ctx.lineWidth = 4; ctx.strokeRect(p.x - p.width/2, p.y, p.width, p.height);

                if (p.y + p.height < 0) projectiles.splice(index, 1);
                if (activeBoss && activeBoss.y > 0 && p.x > activeBoss.x - activeBoss.width/2 && p.x < activeBoss.x + activeBoss.width/2 && p.y < activeBoss.y + activeBoss.height/2) {
                    activeBoss.hp -= p.damage; createExplosion(p.x, p.y, p.color, 5); projectiles.splice(index, 1);
                    if (p.type === 'heavy_rocket') { createExplosion(p.x, p.y, "orange", 30); ctx.fillStyle = "rgba(255, 165, 0, 0.5)"; ctx.beginPath(); ctx.arc(p.x, p.y, 60, 0, Math.PI*2); ctx.fill(); }
                    checkLevelComplete(); 
                }
            });

            enemies.forEach((enemy, eIndex) => {
                enemy.y += enemy.speed; ctx.font = "45px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("üëΩ", enemy.x, enemy.y);
                if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < pSize + 20) { takeDamage(30); createExplosion(enemy.x, enemy.y, "green", 40); enemies.splice(eIndex, 1); checkLevelComplete(); return; }
                if (enemy.y > canvas.height) { takeDamage(15); enemies.splice(eIndex, 1); checkLevelComplete(); return; }
                projectiles.forEach((p, pIndex) => {
                    if (enemy.y > 0 && p.x > enemy.x - 25 && p.x < enemy.x + 25 && p.y < enemy.y + 25 && p.y + p.height > enemy.y - 25) {
                        createExplosion(enemy.x, enemy.y, "#00ff00", 20); enemies.splice(eIndex, 1); if (level < 10 && p.type === 'laser') projectiles.splice(pIndex, 1); 
                        
                        recordPoints(10);
                        checkLevelComplete();
                    }
                });
            });
        }

        // --- 4. END GAME & FINALIZE POINTS (From Manual Screenshot 1192) ---
        async function endGame() { 
            isGameOver = true; 
            if (survivalPointTimer) clearInterval(survivalPointTimer); 
            if (musicInterval) clearInterval(musicInterval);

            document.getElementById('gameOverScreen').style.display = 'flex'; 
            document.getElementById('finalScore').innerText = score; 
            
            // "Ends the current game round and commits all points"
            if (ogp && typeof ogp.endGame === 'function') {
                try {
                    await ogp.endGame(); 
                } catch (e) {
                    console.log("Play.fun endGame error:", e);
                }
            }
        }
        
        function restartGame() { location.reload(); }
    </script>
</body>
</html>
